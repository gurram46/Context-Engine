"""OpenRouter integration for Qwen3 Coder model"""

import json
import requests
from typing import Optional, Dict, Any

class OpenRouterClient:
    """Client for OpenRouter API"""
    
    SYSTEM_PROMPT = """You are the Context Engine summarizer.
Always produce clean, structured Markdown for `.context/context_for_ai.md`.

Rules:
- Organize into: Baseline, ADRs, Session Notes, Cross-Repo Notes
- Strip all inline code comments except API docstrings
- Summarize configs without secrets
- Use bullet points and short paragraphs
- If unknown, output "UNKNOWN"
"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://openrouter.ai/api/v1"
        self.model = "qwen/qwen3-coder:free"
    
    def summarize(self, content: str, task: str = "summarize") -> Optional[str]:
        """Summarize content using Qwen3 Coder"""
        if not self.api_key:
            return None
        
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
            "HTTP-Referer": "https://github.com/context-engine",
            "X-Title": "Context Engine"
        }
        
        prompt = self._build_prompt(content, task)
        
        data = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": self.SYSTEM_PROMPT},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.3,
            "max_tokens": 4000
        }
        
        try:
            response = requests.post(
                f"{self.base_url}/chat/completions",
                headers=headers,
                json=data,
                timeout=30
            )
            response.raise_for_status()
            
            result = response.json()
            return result.get("choices", [{}])[0].get("message", {}).get("content", "")
        
        except (requests.RequestException, json.JSONDecodeError, KeyError) as e:
            print(f"Error calling OpenRouter API: {e}")
            return None
    
    def _build_prompt(self, content: str, task: str) -> str:
        """Build prompt based on task type"""
        if task == "summarize":
            return f"""Summarize this code file for context bundling. 
Focus on structure, key functions, and dependencies.
Remove inline comments but keep docstrings.

Content:
{content}"""
        
        elif task == "compress":
            return f"""Compress this configuration file.
Remove secrets, summarize values, keep structure.

Content:
{content}"""
        
        elif task == "bundle":
            return f"""Create a structured context bundle from these components.
Organize into clear sections with headers.

Content:
{content}"""
        
        else:
            return content
    
    def generate_context_bundle(self, baseline: str, adrs: str, 
                               session: str, cross_repo: str) -> str:
        """Generate the final context_for_ai.md content"""
        
        # Build the complete context
        sections = []
        
        if baseline:
            sections.append(f"## Baseline\n\n{baseline}")
        
        if adrs:
            sections.append(f"## Architectural Decision Records (ADRs)\n\n{adrs}")
        
        if session:
            sections.append(f"## Session Notes\n\n{session}")
        
        if cross_repo:
            sections.append(f"## Cross-Repository Notes\n\n{cross_repo}")
        
        full_content = "\n\n---\n\n".join(sections)
        
        # Try to get AI-enhanced version
        ai_version = self.summarize(full_content, task="bundle")
        
        # Fall back to manual version if AI fails
        if not ai_version:
            return f"""# Project Context for AI Tools

{full_content}

---

*Generated by Context Engine V1*
"""
        
        return ai_version
